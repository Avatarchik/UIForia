

Music: luiz gonzales -- ethereal

Style {
    
    GetLayoutContentBox() {
        return new Rect() {
            x = style.contentX,
            y = style.contentY,
            w = style.GetLayoutWidth(layouttype),
            h = style.GetLayoutHeight(layouttype)
        }
    }

    GetLayoutWidth(type) {
        return {
            preferred: text || image ? text.preferred : GetPreferredWidth()
        }
    }

    GetPreferredWidth() {
        if(text || image) {
            return text ? text.preferred : image.preferred
        }
        switch(unit) {
            case Unit.Pixel:
                return width;
        }
    }

}

a auto
    b 10px
        x parent
    c parent -> use content size or 0 instead
        d 20px
    f 200vh
        g parent
            e parent

size != layout

flex layout column -> auto
    item 20px
    item parent (invalid)
    item auto

gridLayout

flexLayout.GetHeight() {
    if(auto) {
        // do layout -> return ((max child y + height) - min child y)
    }
    if (parent) {
        if(parent == auto) -> return invalid
        return parent.height * height.value;
    }
    if (fixed) {
        return height.value;
    }
    if (viewport) {
        return canvas.height * height.value;
    }
}

flexLayout.GetOverflowHeight() {

}

layout output = rect tree?

GetLayoutHeight() {
    switch(unit) {
        case Pixel: return height;
        case Parent: 
            if parent is content relative
                return 0;
            return parent.GetLayoutContentBox().height;
        case Viewport:
            return height * viewport.height
        case Content:
            return contentBox.verticalSpace + Layout() // need to actually do layout here I think
    }
}

foreach child
    if child.size type == parent relative

if height == 100% of parent
    if parent is fixed -> no problem
    if parent is parent relative -> no problem
    if parent is vh relative -> no problem
    if parent is content relative -> FAIL treat child as content relative instead, or maybe 0

if parent is content based and child is parent based,
CSS implicitly converts the child to 'auto', meaning content based
this is really confusing. maybe its nicer to set it to 0 or throw a big ass warning


RectPosition
LayoutPosition
FlowPosition

if rect.x is 'auto' 
    x = whatever parent says it should be, ie 0 if first child, else previous child.x + width

if rect.x is fixed
    x = rect.x
    in flow = false if direction is row, true if direction is column

if rect.x is viewport based
    in flow = false

if rect.w = 'auto'
    w = content width

if rect.y is 'auto'

if rect.h is 'parent'
    h = parent.height || if parent height is 'content | auto' -> 0 or content height?

Layout = Flow | FixedFlow
    Flow -> expand w / h to contain children
    FixedFlow -> no expanding
    Flex -> Flexbox




LayoutType
LayoutDirection
Units
Colors
ContentBox
Urls / Asset Pointers
Int
Float
Visibility
Overflow

Style {
    color: rgba(1, 2, 3, 4.4);
    font: url('path');
    rgb($index * 4, 1, 4);
}

context.SetAlias("rgb", Color.constructor);
context.SetAlias("url", AssetPointer);
context.SetAlias("LayoutType", LayoutType);

style.Visibility="Visible"
style.Visibility="{isVisible ? $visible : $hidden}"
style.LayoutDirection="$Column"
style.LayoutType="$Flex";
style.hover.rect={ $Rect(10, 5, 2, 5) }
style.font="{url(someUrlField)}"

context.SetFunctionAlias("Rect", () => new Rect());

class StyleBinding_LayoutType {

    public void Execute(UIElement element, UITemplateContext context) {
        context.SetAlias("Flex", LayoutType.Flex);
        context.SetAlias("Grid", LayoutType.Grid);
        context.SetAlias("Stack", LayoutType.Stack);
        context.SetAlias("None", LayoutType.None);
        LayoutType layoutType = expression.EvaluateTyped(context);
        if(layoutType != element.style.layoutType) {
            element.style.layoutType = layoutType;
            context.view.MarkForRendering(element);
        }
        context.RemoveAlias("Flex");
    }

}

class StyleBinding_BackgroundColor {

    public readonly Expression<Color> expression;

    public void Execute(UIElement element, UITemplateContext context) {
        context.SetFunctionAlias("Color", (float r, float g, float b) => {
            return new Color(r, g, b);
        })
        Color color = expression.EvaluateTyped(context);
    }

}

class MethodCallExpression<T, U, V, W, Z> : Expression<Z> {

    public override Z EvaluateTyped(ExpressionContext context) {
        
        context.GetMethod<T, U, V, W, Z>(methodName);

        return method.Invoke(
            arg0.EvaluateTyped(context), 
            arg1.EvaluateTyped(context),
            arg2.EvaluateTyped(context),
            arg3.EvaluateTyped(context)
        );

    }

}

class MethodPointerExpression {

    public Expression[] args;

    public override Func<T> EvaluateTyped(ExpressionContext context) {
        return new MethodPointer(method, args);
    }

}

Render Primitives:
    Text
    TextMeshProText
    RawImage
    ProceduralImage
    RectMask
    PolygonMask

When style changes such that it needs to be rendered:
    Border,
    Color,
    Opacity,
    Background,
    Material,
    Shadow,
    Visibility,
    etc

style will update these properties based on the type of primitive
if it wasn't rendered before we automatically create an appropriate primitive(s)
if it no longer needs to render, we remove the primitive

Some things have a 'proxy' parent such as children of a control flow node
that node is never renderable

layout traversal is of all non proxy elements

   handle creating and removing
            handle filtering
            handle moving index (maybe)
            
            how do you behave with layout since it has an implicit parent element
            1. repeat is inline and inserts children to parent scope
                need to manage which elements belong to which index
                need to set index in bindings somehow
                
            2. repeat has a special layout handler
            
            3. 2 variants -- inline repeat, regular repeat
            
            inline repeat is not style-able at all
            block repeat is treated as a normal element
            
            for inline need to solve context setting
            
            probably with non rendering children that contain the others
            these children exist only in the binding hierarchy
            
            'parent' is starting to be fuzzy
            we have 
                actual parent
                template parent
                render parent
                layout parent
                binding parent
                style parent?
                input parent?
                animation parent?
                scope parent?
            skip tree can be powerful here
            
            when as a user do I ever need to access my parent? probably never, only the systems need it
            probably never need to touch children either
            
            repeat.enter()
                context.SetAlias("$index", i);

Layout runs top down where each box is told how much space they get by their parent

    Boxes can overflow and underflow

    Flex layout will size children based on overflow / underflow / remaining space and may apply wrapping

    Flow layout will not grow / shrink things but may apply wrapping

    Grid layout will grow / shink based on grid size

    Fixed layout will do nothing and just respect child positioning

    children can be 'in flow' or 'out of flow' 
        in flow means they are positioned by their corresponding parent layout
        out of flow means they are ignored and can position themselves however they like
        there should be option for size computations to include / exclude out of flow elements

    an element size can depend on the size of it's children. 
        in this case content size is computed:
        for each in flow child
            size += breadth of child w/o wrapping
            if the sizing of a child is parent relative - treat it as 0 and log a warning
        for each out of flow child
            if breadth is greater than size-so-far
                size-so-far = out of flow child extents
        clamp final size to min/max

    layout ignores scrolling and masking, those are applied by the render system

    layout needs to compute children based on the content box and not the full breadth of the parent
        so if 100 width parent has margin 10 and padding 10, content box = 60 (100 - margin(20) - padding(20))

    Layout.Run(Rect viewport, Rect sizeComputedFromParentInLocalSpace, LayoutData data) {
        float contentStartX = sizeComputedFromParentInLocalSpace.x + contentBox.fullSizeLeft;
        float contentEndX = sizeComputedFromParentInLocalSpace.x - contentBox.fullSizeRight
        float usableWidth = contentEndX - contentStartX;
    }

When a style changes it just reports the change to which ever system(s) care about it
That way systems never need to query style properties which *might* be slightly expensive

parent == content && child == parent -> 0

need to link style -> layout data & include defaults
need default flex behavior for when size is 0 -> ie split equally between children



Mission: Make Unity UI Great Again(strike through) for the first time

Matt's super-duper-ui-project is coming soon(tm) which will let us 
build snazzy UI's faster than ever. The scope of the project doesn't
currently include editor tools for building UI, until now! 

This Discover Week project will attempt to answer two questions:
    1. On a scale of 1 to awesome: how awesome can editor UI tooling be?
    2. See question 1.










